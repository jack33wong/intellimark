---
alwaysApply: true
---

# Cursor AI Rules (MDC Format)

These rules enforce clean architecture, testing best practices, security, and documentation standards.  
Cursor should apply the most relevant section depending on the file type (src, tests, docs, etc.).

## ðŸ—ï¸ Style
```rules
- Use TypeScript with strict typing. Avoid `any` unless absolutely necessary.
- Always follow Prettier formatting and ESLint rules.
- Keep functions small, single-purpose, and aligned with SOLID principles.
- No duplicated logic across modules.

## Architecture
- Follow Clean Architecture with clear layers: controllers â†’ services â†’ repositories.
- Use dependency injection instead of hardcoded imports.
- Keep business logic separate from I/O (e.g., request/response handling).
- Never put database logic directly in controllers.
- Always load configuration and secrets from environment variables (process.env).

## Testing
- Use Jest for all unit and integration tests.
- Each major function/class like (question detection, parse exam text) has a matching test file. e.g. parseExamText.ts has a parseExamText.test.ts  
- Tests MUST NOT duplicate or re-implement business logic.
- Tests MUST ONLY call real implementations with inputs and compare against hardcoded expected outputs.
- Do not include parsing, string manipulation, or transformation logic inside tests.
- Use mocks/stubs for databases and external APIs.
- Write both positive (success) and negative (failure/edge) test cases.
- Maintain >80% test coverage on all new code.

## Security
- Never hardcode API keys, tokens, passwords, or credentials.
- Always use environment variables for secrets and configuration.
- Validate all user input (e.g., with Zod or Joi).
- Apply authentication and authorization to all protected routes.

## Documentation
- Every public function and class must include JSDoc comments.
- Update README.md or ARCHITECTURE.md whenever new modules are added.
- For APIs, include example requests and responses in comments.

## Git Workflow
- Use feature branches; never commit directly to main.
- Branch naming: feat/*, bugfix/*, chore/*, refactor/*.
- Commit messages MUST follow Conventional Commits (feat:, fix:, docs:, refactor:, test:, chore:).

## programming practice
- never use other port for local development, only 3000 for frontend and 5001 for backend
- never remove working code during refactor e.g. "I removed the auto-fill functionality when I refactored the code"
- nerver use in memory data for frontend display expect it is designed by user. e.g. The issue is that the frontend is displaying data from the in-memory jsonCollections array, but the actual data should come directly from Firestore.
- NEVER implement mock versions of production code. Always implement the real functionality directly.
- If testing is needed, use proper mocks/stubs for external dependencies, not fake implementations of core business logic.  

## deployment
- **CRITICAL: NEVER auto deploy to production**
- **CRITICAL: NEVER change program logic during deployment**
- **CRITICAL: Production and local must have IDENTICAL program logic**
- **CRITICAL: Only fix deployment issues (config, paths, dependencies) - NEVER change business logic**
- **CRITICAL: If production needs different logic, it's a bug that needs to be fixed in the source code, not a deployment change**
- **CRITICAL: Deployment should only involve: copying files, installing dependencies, configuring environment variables**
- **CRITICAL: Any logic changes must be made in the source code and then deployed, never changed during deployment** 

##  Correct Test Example
import { parseExamText } from "../src/parser";

test("parses exam text correctly", () => {
  const input = "Q1: Simplify âˆš9";
  const result = parseExamText(input);
  expect(result).toEqual({
    questionNumber: "1",
    text: "Simplify âˆš9"
  });
});

##  Wrong Test Example
// âŒ Do NOT duplicate parsing logic inside tests
test("bad test example", () => {
  const input = "Q1: Simplify âˆš9";
  const result = {
    questionNumber: input.split(":")[0].replace("Q", ""),
    text: input.split(":")[1].trim()
  };
  expect(result).toEqual({
    questionNumber: "1",
    text: "Simplify âˆš9"
  });
});



