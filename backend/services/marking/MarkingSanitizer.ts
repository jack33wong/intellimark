// src/services/ai-marking/MarkingSanitizer.ts

/**
 * THE IRON DOME (V3): Pure Safety
 * Guarantees that marks are PRESERVED, only bad links are SEVERED.
 */
export function sanitizeAnnotations(
    rawAnnotations: any[],
    ocrBlocks: any[],
    instructionHeatMap?: Set<string>
): any[] {

    if (!Array.isArray(rawAnnotations) || rawAnnotations.length === 0) {
        return [];
    }

    return rawAnnotations.map(anno => {
        // 1. SAFETY: If already UNMATCHED, force line_id to null and PASS.
        // This ensures we keep "Ghost Marks" generated by the AI.
        if (anno.ocr_match_status !== 'MATCHED') {
            return anno;
        }

        // 2. CHECK: Does the ID exist?
        // If not, KEEP THE MARK but set to UNMATCHED.
        // We prioritize linked_ocr_id which is the physical evidence ID.
        // Support both underscore and camelCase from AI
        // [V28 FIX] Prioritize physical linked ID over classification line_id
        const searchId = anno.linked_ocr_id || anno.linkedOcrId || anno.linked_id || (anno.line_id?.startsWith('p') && anno.line_id?.includes('_ocr_') ? anno.line_id : null);

        if (!searchId) {
            return { ...anno, ocr_match_status: 'UNMATCHED' };
        }

        const block = ocrBlocks.find((b: any) => b.id === searchId);
        if (!block) {
            console.warn(`⚠️ [IRON DOME] Block ID '${searchId}' not found in OCR list. Switching to UNMATCHED.`);
            return { ...anno, ocr_match_status: 'UNMATCHED' };
        }

        // 2.5 FORBIDDEN BLOCK CHECK (Heat Map)
        // If the AI linked to an OCR block that we've identified as Question Text or Instructions,
        // we SEVER the link immediately. This forces the system to use the handwriting ID
        // (line_id) or the zone anchor instead.
        if (instructionHeatMap?.has(searchId)) {
            return { ...anno, ocr_match_status: 'UNMATCHED', line_id: anno.line_id, linked_ocr_id: null, linkedOcrId: null };
        }

        // 3. DIGIT FIDELITY CHECK (LENIENT V4)
        // Philosophy: We keep the link (even if text is messy) to preserve the X/Y coordinates.
        // We let the downstream "Spatial Sovereignty" logic decide if the link is valid.
        const studentText = (anno.student_text || anno.studentText || "").toString();
        const ocrText = block.text.toString();

        const studentDigits = [...new Set(studentText.match(/\d/g) || [])];

        for (const digit of studentDigits) {
            if (!ocrText.includes(digit)) {
                // [V4 FIX] We no longer sever the link here for non-instruction blocks.
                break;
            }
        }

        // If passed all checks, return original
        return anno;
    });
}